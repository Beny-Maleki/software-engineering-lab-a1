# software-engineering-lab-a1
<div dir='rtl'>

۴. دستور git checkout برای وقتی استفاده می‌شود که می‌خواهیم تغییرات را در working directory 
دور بیاندازیم.

دستور git reset وقتی استفاده می‌شود که می‌خواهیم یک فایل را unstage کنیم و تغییراتمان را به working directory برگردانیم.
این دستور می‌تواند به قصد حذف کردن commitها از مخن محلی نیز به کار رود.

دستور git revert  موقعی استفاده می‌شود که می‌خواهیم commitها را از مخن remote  حذف کنیم. 
که این کار را با ساخت یک کامیت دیگر که تغییرات یک کامیت دیگر را undo می‌کند انجام می‌دهیم.


دستور git restore در واقع فایل‌هایی که در working tree هستند را از یک index یا یک commit دیگر بازیابی می‌کند. این دستور شاخه را آپدیت نمی‌کند. 


https://www.geeksforgeeks.org/git-difference-between-git-revert-checkout-and-reset/

https://blog.git-init.com/how-to-undo-changes-in-git-using-reset-revert-and-restore/


۵. استیج کردن به معنای نهایی کردن بخشی از/تمام تغییرات انجام‌شده بر روی پروژه نسبت به آخرین کامیت برنچ فعال است. در اصل فرضاً ممکن است که یک فایلی را به گیت  اضافه کنیم ولی صرفاً قسمتی از آن تغییرات کامل باشد و بخواهیم فقط همان را کامیت کنیم.

https://softwareengineering.stackexchange.com/questions/119782/what-does-stage-mean-in-git


اغلب، زمانی که روی بخشی از پروژه خود کار می کنیم، همه چیز به‌هم‌ریخته است. و گاهی می‌خواهیم برای مدتی شاخه خود راعوض کنیم تا روی چیز دیگری کار کنیم. مشکل این است که ما نمی‌خواهیم یک کار نیمه تمام را کامیت کنیم تا بتوانیم بعداً به این نقطه بازگردیم. برای این منظور می‌توانیم از دستور git stash استفاده کنیم.

دستور Stash حالت به‌هم‌ریخته working directory ما را می گیرد؛ یعنی فایل‌های ردیابی‌شونده اصلاح شده و تغییرات stage شده، را می‌گیرد و  آن‌ها را در پشته ای از‌ تغییرات ناتمام ذخیره می‌کند که می توانید هر زمان که بخواهید مجدداً اعمال کنید (حتی در یک شاخه دیگر).

https://git-scm.com/book/en/v2/Git-Tools-Stashing-and-Cleaning


۶. در مخازن گیت ساختاری که فایل‌ها ذحیره می‌شوند به این صورت است که برای هر فایل یک 
blob object
نگهداری می‌کند که محتوای فایل اصلی را در خود دارد. هنگامی که در ویرایشگر یک فایل را تغییر می‌دهیم گیت متوجه این تغییر در 
blob 
مربوطه می‌شود و آن را دنبال می‌کند. از طرفی ساختار پوشه‌ها به کمک 
tree
ساخته می‌شود. به این صورت که هر 
tree
نشان‌دهنده‌ی یک پوشه است و به تعدادی 
tree
یا
blob 
اشاره می‌کند. 
treeهایی
که یک 
tree
پدر به آن اشاره می‌کند، در عمل زیرپوشه‌ی آن پوشه‌ی پدر هستند.
در نهایت هر 
commit
یک تصویر از وضعیت 
object model
کل 
working directory
ما است. به این معنا که نشان می‌دهد وضعیت هر کدام از 
treeها
و
blobهای 
ما در آن لحظه از زمان که این تصویر گرفته شده به چه صورت بوده است.

![Alt text](https://github.blog/wp-content/uploads/2020/12/commit.png?resize=399%2C268?w=399)

در عکس بالا مثلث‌ها 
tree
مربع‌ها 
blob
و
دایره‌ها
commitها 
هستند که در عمل 
snapshotهایی
از وضعیت کل 
object model
در یک لحظه هستند.


https://github.blog/2020-12-17-commits-are-snapshots-not-diffs/


